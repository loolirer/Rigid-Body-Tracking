# The Algorithm

This algorithm is inspired in [this article](https://www.scitepress.org/papers/2007/20528/20528.pdf). It absorbed the ideas of generating a matrix containing distance between points and using the deviation parameters of the capturing system to make validate these values.

## Description

### Input

The algorithm will receive a point cloud for analysis and a list of rigid bodies to find within it.

The point cloud is described as a set of $p$ points scattered in space. A list of $n$ rigid bodies is given, each rigid body $r$ is a set of $r_i \ (1 \leq i \leq n)$ point coordinates. Notice that $\sum _{i=1}^{n}r_i = p$ must be true, otherwise it would imply in occlusions in the point cloud or unknown rigid bodies in the scene.

### Output

The output must be a partition of the initial point cloud: a list of $n$ set of points, each set containing the points judged to be part of a separate rigid body. Note that different rigid bodies *must not* share any number of points: all rigid bodies should have their unique set of points in space.

## Current Version (v4)

Currently, the partition algorithm (in the function `rb_identify`) can be described as:

1. The function is called with the following parameters:
   1. Scene point cloud $pc$
   2. Pre-calculated list of distance matrices of the known rigid bodies $rb_d$
   3. The double of the maximum capturing error $2 \cdot \epsilon$
2. The distance matrix of the point cloud received is calculated
3. For each interval $i$ in a float set generated by $rb_d$, search in $p_c$ distance matrix if there is any similar distance $d_ij$ 
- If $d_ij$ is inside any interval of the float set, $d_ij$ is considered similar
- For each similar $d_ij$, vertices $i$ and $j$ will be linked in a graph $G_d$
4. The Girvan-Newman community detection algorithm will be used to find separate the rigid bodies
Let $e_i$ being the ideal number of distances that should be detected and $e_d$ the actual number of distances detected, the algorithm will run $e_d - e_i$ times (it will cut $e_d - e_i$ edges)
5. Having the excess edges removed of the graph, it will find the disconnected subgraphs of the modified $G_d$
6. If the partition was done correctly, it returns a list of sets containing point coordinates
If not, it returns an empty list 

### Observations

General features:

- It is noticeable that the algorithm abstracts the matching coordinates problem to a graph problem.
- In some cases when two separate rigid bodies are close, a distance $d_ij$ between two of their points could coincide with some of their internal distances, connecting them in the graph abstraction. These coincidences will be called **ambiguities**.
- The kinematics section is made to simulate some point cloud capturing conditions.

Regarding the main section:

- Every length unit is in centimeters.
- The main code simulates a point cloud of a captured scene composed of a certain quantity of the indoor Parrot Mambo Drone.
  - A mambo is modeled by 3 points that matches approximately it's dimensions.
  - Each of them are randomly rotated and randomly translated into a predefined parallelepiped. 
- A point cloud is created by taking each point of the mambos in the scene (in a random sequence) and displacing them randomly in a random direction with a maximum distance of the maximum error in the system.
- The main algorithm is then called and timed. 
- Finally, it is asked if the user wants to save the point cloud.

### Problems

- This version support *most* ambiguities: most ambiguities (but not all) are taken away by the Girvan-Newman algorithm.

---