import numpy as np
import networkx as nx
from scipy.spatial.distance import pdist, squareform

# Optimization
def float_set(float_list, delta):
    float_list, fset = sorted(float_list), []
    lower, upper = 0, 0
    while upper < len(float_list):
        if abs(float_list[upper] - float_list[lower]) < delta:
            upper += 1
            if upper == len(float_list) - 1:
                fset.append((float_list[lower] - delta, float_list[upper] + delta))
        else:
            fset.append((float_list[lower] - delta, float_list[upper - 1] + delta))
            lower = upper

    return np.array(fset) 

# Partition algorithm
def partition(scene_pcd, scene_rb, tolerance):
    rb_distances = np.concatenate([rb.distance_list() for rb in scene_rb])
    pcd_distances = squareform(pdist(scene_pcd, metric='euclidean'))

    n_points, n_rb = len(scene_pcd), len(scene_rb)
    ideal_graph_size = len(rb_distances)

    # Graph composition
    distance_graph = nx.Graph()
    for interval in float_set(rb_distances, tolerance):
        for i in range(n_points):
            for j in range(i + 1, n_points):
                # If distance belongs to a valid interval
                if pcd_distances[i][j] > interval[0] and pcd_distances[i][j] < interval[1]:
                    distance_graph.add_edge(i, j)
    
    # Number of edges generated by ambiguities 
    ambiguities = distance_graph.size() - ideal_graph_size
    
    # Girvan-Newman community detection algorithm
    for _ in range(ambiguities):
        edge_betweenness = nx.edge_betweenness_centrality(distance_graph).items()
        # Highest betweenesss centrality edge
        edge_to_delete = sorted(edge_betweenness, key=lambda pair: -pair[1])[0][0]
    
        distance_graph.remove_edge(*edge_to_delete)

    # Get disconnected components of the distance graph post edge cuts
    pcd_partition = [list(cc) for cc in nx.connected_components(distance_graph)]

    # If the number of partitions is equal to the number of rigid bodies in the scene 
    if len(pcd_partition) == n_rb: 
        return [[scene_pcd[marker] for marker in partition] for partition in pcd_partition], ambiguities
    else: # Incorrect partition 
        return [], ambiguities